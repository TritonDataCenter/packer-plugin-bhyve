package bhyve

import (
	"bytes"
	"fmt"
	"log"
	"os/exec"
	"strconv"
	"sync"
	"time"

	"github.com/hashicorp/packer-plugin-sdk/multistep"
)

type Driver interface {
	Start() error
	Stop() error
	WaitForShutdown(<-chan struct{}) bool
}

type BhyveDriver struct {
	config  *Config
	state   multistep.StateBag
	vmCmd   *exec.Cmd
	vmRetCh <-chan int
	vmErrCh <-chan error
	lock    sync.Mutex
}

func (d *BhyveDriver) Start() error {
	d.lock.Lock()
	defer d.lock.Unlock()

	if d.vmCmd != nil {
		panic("Existing VM state found")
	}

	// Use the same slots as pci_slot_t in
	// illumos-joyent usr/src/lib/brand/bhyve/zone/boot.c
	const (
		SlotHostBridge int = 0
		SlotCDROM          = 3
		SlotBootDisk       = 4
		SlotNIC            = 6
		SlotCDROM2         = 7 // Additional CD generated by CDFiles
		SlotFBuf           = 30
		SlotLPC            = 31
	)

	common_args := []string{
		"-D",
		"-H",
		"-c", d.config.CPUConfig.cmdline(),
		"-l", "bootrom,/usr/share/bhyve/uefi-rom.bin",
		"-m", strconv.Itoa(d.config.MemorySize),
		"-s", fmt.Sprintf("%d,hostbridge,model=i440fx", SlotHostBridge),
		"-s", fmt.Sprintf("%d,virtio-blk,%s",
			SlotBootDisk, d.state.Get("bhyve_disk_path").(string)),
		"-s", fmt.Sprintf("%d,virtio-net-viona,vnic=%s",
			SlotNIC, d.config.VNICName),
		"-s", fmt.Sprintf("%d:0,fbuf,vga=off,rfb=%s:%d,password=%s",
			SlotFBuf, d.config.VNCBindAddress,
			d.state.Get("vnc_port").(int),
			d.state.Get("vnc_password").(string)),
		"-s", fmt.Sprintf("%d:1,xhci,tablet", SlotFBuf),
		"-s", fmt.Sprintf("%d,lpc", SlotLPC),
	}

	// cd_path is generated if cd_files is specified, use it for both the
	// initial boot and post-reboot.
	extra_cd_path, ok := d.state.Get("cd_path").(string)
	if ok && extra_cd_path != "" {
		common_args = append(common_args,
			"-s", fmt.Sprintf("%d,ahci-cd,%s", SlotCDROM2,
				extra_cd_path))
	}

	// Set up two argument lists, one for the initial install with the boot
	// CDROM attached, and one without, to ensure that we boot from disk
	// for the post-install steps.
	boot_args := []string{}
	boot_args = append(boot_args, common_args...)
	boot_args = append(boot_args,
		"-s", fmt.Sprintf("%d,ahci-cd,%s", SlotCDROM,
			d.state.Get("iso_path").(string)),
		d.config.VMName,
	)

	reboot_args := []string{}
	reboot_args = append(reboot_args, common_args...)
	reboot_args = append(reboot_args,
		d.config.VMName,
	)

	// bhyve exits when a VM reboots which is a bit annoying in this
	// context.  We need to check for this and restart it on success so
	// that any post-install provisioning steps can run.  Once complete
	// the VM is powered off which is a non-zero exit status.
	retCh := make(chan int, 1)
	errCh := make(chan error, 1)
	var cmd *exec.Cmd

	go func() {
		var first bool = true
		var rc int = 0
		var stderr bytes.Buffer

		for {
			if first {
				log.Printf("Starting bhyve VM %s", d.config.VMName)
				log.Printf("boot_args %v", boot_args)
				cmd = exec.Command("/usr/sbin/bhyve", boot_args...)
			} else {
				log.Printf("Restarting bhyve VM %s after reboot", d.config.VMName)
				log.Printf("reboot_args %v", reboot_args)
				cmd = exec.Command("/usr/sbin/bhyve", reboot_args...)
			}
			cmd.Stderr = &stderr

			if err := cmd.Start(); err != nil {
				if first {
					errCh <- fmt.Errorf("Error starting VM: %s", err)
				} else {
					errCh <- fmt.Errorf("Error restarting VM: %s", err)
				}
				rc = 1
				break
			}

			first = false
			err := cmd.Wait()

			// 0 = rebooted
			// 1 = powered off
			// 2 = halted
			// 3 = triple fault
			// 4 = exited due to an error
			if err == nil {
				continue
			} else {
				if status, ok := err.(*exec.ExitError); ok {
					rc = status.ExitCode()
					// convert power off or halt to success
					if rc == 1 || rc == 2 {
						rc = 0
					} else {
						errCh <- fmt.Errorf("%s", stderr)
					}
				}
				break
			}
		}
		retCh <- rc

		d.lock.Lock()
		defer d.lock.Unlock()

		d.vmCmd = nil
		d.vmRetCh = nil
		d.vmErrCh = nil
	}()

	// Give bhyve a few seconds to start up to catch errors
	select {
	case exit := <-retCh:
		if exit != 0 {
			res := <-errCh
			return res
		}
	case <-time.After(2 * time.Second):
	}

	d.vmRetCh = retCh
	d.vmErrCh = errCh
	d.vmCmd = cmd

	return nil
}

func (d *BhyveDriver) Stop() error {
	d.lock.Lock()
	defer d.lock.Unlock()

	if d.vmCmd != nil {
		if err := d.vmCmd.Process.Kill(); err != nil {
			return err
		}
	}

	return nil
}

func (d *BhyveDriver) WaitForShutdown(cancelCh <-chan struct{}) bool {
	d.lock.Lock()
	retCh := d.vmRetCh
	d.lock.Unlock()

	if retCh == nil {
		return true
	}

	select {
	case <-retCh:
		return true
	case <-cancelCh:
		return false
	}
}
